/**
 * LED Tower Control System
 * 
 * An ESP32-based IoT device for controlling a Red/Yellow/Green/Blue LED tower
 * via MQTT commands. Provides real-time status indication for monitoring
 * ongoing events, system statuses, or notifications.
 * 
 * Hardware: ESP32 S2 Mini controlling 4-color LED tower via N-Channel MOSFETs
 * Communication: MQTT over WiFi
 * 
 * Command Format: "<color> <action>"
 * Colors: red, yellow, green, blue, all
 * Actions: on, off, fflash (fast flash), sflash (slow flash)
 * 
 * MQTT Topics:
 * - device/cmd: Receives commands
 * - device/state: Reports current LED states in JSON
 * 
 * Originally generated by AI assistants (ChatGPT 4, Bard, Hugging Face)
 * with developer modifications and enhancements.
 * 
 * @author Developer with AI assistance
 * @date June 2023 - January 2026
 * @version 1.0
 * / 

- ESP32
  - GPIO 4 - Red
  - GPIO 5 - Yellow
  - GPIO 6 - Green
  - GPIO 7 - Blue
- Arduino enviroment
- MQTT
  - accept command strings from the device/cmd topic
    - coomands are in the format of "color cmd"
      - where command is:
        - on
        - off
        - fflash (fast flash)
        - sflash (slow flash)
      - where color is
        - red
        - green
        - yellow
        - blue
      - addition commands:
        - all off
        - all on
      - commands can be issued asynchronously
  - states can be monitored on device/state
- Flash fast
- Flash slow
- Fade on and off

S2 Mini

https://www.wemos.cc/en/latest/s2/s2_mini.html

** Notes

Currently the Green and Blue haven't turned on. (fixed, all light now, incorrectly wired)

1. First priority see if the Green and Blue LEDs work. (they do)
2. Second make all work manually. (it does)
3. Third see if I can get an ESP32 to control the LED (in progress)
4. Add dim/bright/flash

. 24vDC -> Manual Switch -> Controller board -> LEDs (unmarked, plugin cable)
. White        R                   +---------<- LEDs R
.              Y                                     Y
.              G                                     G
.              Blue                                  Blue
. Black        Black                                 Black
.                                                    white ribbon cable

- N-Channel MOSFET - Positive Gate, Switch is on
- P-Channel MOSFET - Negative Gate, Switch is on

[[https://dubiouscreations.com/2020/08/16/building-an-esp32-light-controller/][Building an ESP32 Light Controller]] (PWM & MOSFETs)
https://makeabilitylab.github.io/physcomp/esp32/led-fade.html

https://github.com/makeabilitylab/arduino/blob/master/ESP32/Basics/Fade/Fade.ino

I've got a Wemo ESP32 S2 Mini to control the device

https://www.wemos.cc/en/latest/s2/s2_mini.html
https://www.studiopieters.nl/esp32-s2/

- Features
  - based ESP32-S2FN4R2 WIFI IC
  - Type-C USB
  - 4MB Flash
  - 2MB PSRAM
  - 27x IO
  - ADC, DAC, I2C, SPI, UART, USB OTG
  - Compatible with LOLIN D1 mini shields
  - Compatible with MicroPython, Arduino, CircuitPython and ESP-IDF
  - Default firmware: MicroPython

|------+------+-----+------+------+-------------------|
|    A |    B | USB |    C |    D |                   |
| GPIO | GPIO | CPU | GPIO | GPIO | Notes             |
|------+------+-----+------+------+-------------------|
|   EN |    1 | up  |   40 |   39 | EN = RTS/Chip_PU  |
|    3 |    2 |     |   38 |   37 |                   |
|    5 |    4 |     |   36 |   35 |                   |
|    7 |    6 |     |   34 |   33 |                   |
|    9 |    8 |     |   21 |   18 |                   |
|   11 |   19 |     |   17 |   16 |                   |
|   12 |   13 |     |  Gnd |  Gnd |                   |
|  3v3 |   14 |     |   15 | Vbus | Vbus = USB Power? |
|      |      | 15  |      |      | Onboard LED       |
|------+------+-----+------+------+-------------------|

- Upload Code
  - Make S2 boards into Device Firmware Upgrade (DFU) mode.
  - Hold on Button 0
  - Press Button Reset
  - Release Button 0 When you hear the prompt tone on usb reconnection


*/

#include <WiFi.h>
#include <PubSubClient.h>
#include <ArduinoJson.h>

#include "myWiFi.h" //
#include "myMQTT.h" //
/*
#ifndef ssid
// WiFi credentials.
const char* ssid     = "your_SSID";
const char* password = "your_PASSWORD";
#endif

#ifndef mqtt_server
// MQTT details
const char* mqtt_server   = "your_MQTT_SERVER";
const char* command_topic = "device/cmd";
const char* state_topic   = "device/state";
#endif
*/

WiFiClient espClient;
PubSubClient client(espClient);

// LED GPIO Pin Assignments
// These pins control N-Channel MOSFETs that switch the LED tower lights
int redPin    = 4;  // GPIO 4 - Red LED control
int yellowPin = 5;  // GPIO 5 - Yellow LED control  
int greenPin  = 6;  // GPIO 6 - Green LED control
int bluePin   = 7;  // GPIO 7 - Blue LED control

// Global LED State Management
// JSON document to track current state of all LEDs
// Published to MQTT state topic for real-time monitoring
DynamicJsonDocument doc(1024);  // 1KB buffer for JSON data
JsonObject ledState = doc.to<JsonObject>();  // LED state object

/**
 * ROT47 Encoding/Decoding Function
 * 
 * Simple character encoding that rotates ASCII characters by 47 positions.
 * Currently unused but available for basic string obfuscation if needed.
 * 
 * @param s String to encode/decode (modified in place)
 * @return Pointer to the modified string
 */
char* rot47(char *s) {
    char *p = s;
    while(*p) {
        if(*p >= '!' && *p <= 'O')
            *p = ((*p + 47) % 127);
        else if(*p >= 'P' && *p <= '~')
            *p = ((*p - 47) % 127);
        p++;
    }
    return s;
}

/**
 * Arduino Setup Function
 * 
 * Initializes hardware pins, establishes network connections,
 * configures MQTT client, and sets initial LED states.
 */
void setup() {
  // Configure GPIO pins as outputs for LED control
  pinMode(redPin,    OUTPUT);
  pinMode(yellowPin, OUTPUT);
  pinMode(greenPin,  OUTPUT);
  pinMode(bluePin,   OUTPUT);

  // Establish WiFi connection
  setup_wifi();
  
  // Configure MQTT client
  client.setServer(mqtt_server, 1883);  // Standard MQTT port
  client.setCallback(callback);         // Set message handler

  // Initialize all LEDs to OFF state
  ledState["red"]    = "off";
  ledState["yellow"] = "off";
  ledState["green"]  = "off";
  ledState["blue"]   = "off";
}

/**
 * WiFi Network Setup
 * 
 * Establishes connection to configured WiFi network.
 * Blocks until connection is successfully established.
 */
void setup_wifi() {
  delay(10);  // Brief delay for stability

  // Initiate WiFi connection using credentials from myWiFi.h
  WiFi.begin(ssid, password);

  // Wait for connection to be established
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);  // Check every 500ms
  }
}

/**
 * MQTT Broker Connection Management
 * 
 * Attempts to connect/reconnect to MQTT broker and subscribe
 * to the command topic. Retries every 5 seconds if connection fails.
 */
void reconnect() {
  // Loop until successfully connected to MQTT broker
  while (!client.connected()) {
    if (client.connect("ESP32Client")) {
      // Successfully connected - subscribe to command topic
      client.subscribe(command_topic);
    } else {
      // Connection failed - wait before retry
      delay(5000);
    }
  }
}

/**
 * MQTT Message Callback Handler
 * 
 * Called when a message is received on a subscribed topic.
 * Converts the payload to a string and passes it to command processor.
 * 
 * @param topic The topic the message was received on
 * @param payload The message payload as byte array  
 * @param length The length of the payload
 */
void callback(char* topic, byte* payload, unsigned int length) {
  // Convert byte array payload to String
  String message;
  for (int i = 0; i < length; i++) {
    message += (char)payload[i];
  }
  
  // Process the received command
  processCommand(message);
}

/**
 * Process Individual LED Commands
 * 
 * Parses MQTT command strings in format "<color> <action>"
 * and executes the appropriate LED control action.
 * 
 * @param command String containing color and action separated by space
 * 
 * TODO: Implement continuous patterns (fade, continuous flash)
 * that persist until new command is issued.
 */
void processCommand(String command) {
  // Parse command string: "color action"
  int    index  = command.indexOf(' ');
  String led    = command.substring(0, index);      // Extract color
  String action = command.substring(index + 1);    // Extract action

  // Future enhancement: Implement non-blocking patterns
  // that continue until interrupted by new commands
  // Map color name to GPIO pin number
  int ledPin = 0;
  if (led == "red") {
    ledPin = redPin;
  } else if (led == "yellow") {
    ledPin = yellowPin;
  } else if (led == "green") {
    ledPin = greenPin;
  } else if (led == "blue") {
    ledPin = bluePin;
  } else if (led == "all") {
    // Handle special "all" command for multiple LEDs
    processAllCommand(action);
    return;
  }

  // Execute the requested action on the specified LED
  if (action == "on") {
    // Solid on - LED stays on until changed
    digitalWrite(ledPin, HIGH);
    ledState[led] = "on";
  } else if (action == "off") {
    // Turn off - LED stays off until changed  
    digitalWrite(ledPin, LOW);
    ledState[led] = "off";
  } else if (action == "fflash") {
    // Fast flash pattern - 10 cycles at 100ms intervals
    // NOTE: This is blocking - LED is unavailable during execution
    for(int i = 0; i < 10; i++) {
      digitalWrite(ledPin, HIGH);
      delay(100);
      digitalWrite(ledPin, LOW);
      delay(100);
    }
    ledState[led] = "fflash";
  } else if (action == "sflash") {
    // Slow flash pattern - 5 cycles at 500ms intervals
    // NOTE: This is blocking - LED is unavailable during execution
    for(int i = 0; i < 5; i++) {
      digitalWrite(ledPin, HIGH);
      delay(500);
      digitalWrite(ledPin, LOW);
      delay(500);
    }
    ledState[led] = "sflash";
  } 
  publishState();  // publish updated state
}

/**
 * Process "All" LED Commands
 * 
 * Handles commands that affect all LEDs simultaneously.
 * Currently supports "all on" and "all off" commands.
 * 
 * @param action The action to apply to all LEDs (on/off)
 */
void processAllCommand(String action) {
  if (action == "on") {
    // Turn on all LEDs simultaneously
    digitalWrite(redPin,    HIGH);
    digitalWrite(yellowPin, HIGH);
    digitalWrite(greenPin,  HIGH);
    digitalWrite(bluePin,   HIGH);

    // Update state for all LEDs
    ledState["red"]    = "on";
    ledState["yellow"] = "on";
    ledState["green"]  = "on";
    ledState["blue"]   = "on";
  } else if (action == "off") {
    // Turn off all LEDs simultaneously 
    digitalWrite(redPin,    LOW);
    digitalWrite(yellowPin, LOW);
    digitalWrite(greenPin,  LOW);
    digitalWrite(bluePin,   LOW);

    // Update state for all LEDs
    ledState["red"]    = "off";
    ledState["yellow"] = "off";
    ledState["green"]  = "off";
    ledState["blue"]   = "off";
  }

  // Publish updated state to MQTT
  publishState();
}

/**
 * Publish Current LED State
 * 
 * Serializes the current LED state object to JSON format
 * and publishes it to the MQTT state topic for monitoring.
 */
void publishState() {
  String output;
  serializeJson(ledState, output);
  client.publish(state_topic, output.c_str());
}

/**
 * Main Program Loop
 * 
 * Continuously maintains MQTT connection and processes incoming messages.
 * Handles automatic reconnection if MQTT connection is lost.
 */
void loop() {
  // Check MQTT connection and reconnect if needed
  if (!client.connected()) {
    reconnect();
  }

  // Process incoming MQTT messages
  client.loop();
}

/*
   Local Variables:
   mode:c
   End:
*/
